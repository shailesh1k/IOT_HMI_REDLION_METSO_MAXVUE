#include "arduino_secrets.h"
#include <HT16K33_driver.h>
#include <grove_alphanumeric_display.h>

#include <Servo.h>
#include <DHT.h>
#include <DHT_U.h>
//#include <UART.h>
//#include <MUIU8g2.h>
#include <U8g2lib.h>
#include <U8x8lib.h>
#include <arduino-timer.h>
#include <WiFiNINA.h>
#include <utility/wifi_drv.h>
//MKR WiFi 1010 to TMS320F28379D communication
//#define TX_PIN 14
//#define RX_PIN 13
#define CHB_STATUS_CHA 3
Servo myservo;
byte relay_pin_1 = 1;
Seeed_Digital_Tube tube;


/* 
  Sketch generated by the Arduino IoT Cloud Thing "Untitled 2"
  https://create.arduino.cc/cloud/things/e0e3595f-2602-4288-9a6b-99afd8c354ab 

  Arduino IoT Cloud Variables description

  The following variables are automatically generated and updated when changes are made to the Thing

  String message_one;
  CloudLight button;
  CloudLight drive_CHB_OFF;
  CloudLight drive_CHB_ON;
  CloudLight Drive_Run;
  CloudLight Drive_Stop;
  CloudLight led_on_off;
  CloudLight relay_1;
  CloudTemperatureSensor temperature;
  int led_pwd;
  int pot;
  int servo_1;
  CloudRelativeHumidity humidity;
  CloudSchedule timer;

  Variables which are marked as READ/WRITE in the Cloud Thing will also have functions
  which are called when their values are changed from the Dashboard.
  These functions are generated with the Thing and added at the end of this sketch.
*/

#include "thingProperties.h"
#define DHTPIN A1
#define DHTTYPE DHT11
//uint8_t receivedByte
//byte CHB
int CHB;
uint32_t temp_rpm;
DHT dht(DHTPIN, DHTTYPE);

auto sensor_timer = timer_create_default();  // create a timer with default settings
U8G2_SH1106_128X64_NONAME_F_HW_I2C u8g2(U8G2_R0, /* reset=*/U8X8_PIN_NONE);

bool get_button_pot_state(void *) {

  pot = analogRead(A6);
  tube.displayString("POT", 500);
  delay(1000);
  tube.displayNum(pot);
  delay(15);

  button = digitalRead(0);

  printValues();

  return true;  // repeat? true
}


void setup() {
  // Initialize serial and wait for port to open:
  Serial.begin(9600);
  //Serial1.begin(9600, SERIAL_8N1, RX_PIN, TX_PIN);
  Serial1.begin(9600, SERIAL_8N1);
  // Initialize Serial1 for communication with TMS320F28379D
  //Serial1.begin(9600);
  //Serial1.begin(9600,SERIAL_8N1 , RX_PIN, TX_PIN);
  // This delay gives the chance to wait for a Serial Monitor without blocking if none is found
  analogReadResolution(12);
  delay(500);
  pinMode(relay_pin_1, OUTPUT);
  pinMode(6, OUTPUT);
  pinMode(4, OUTPUT);
  pinMode(A6, INPUT);
  pinMode(A1, INPUT);
  pinMode(5, OUTPUT);
  pinMode(0, INPUT_PULLUP);
  pinMode(CHB_STATUS_CHA, INPUT);
  dht.begin();
  WiFiDrv::pinMode(25, OUTPUT);  //define green pin
  WiFiDrv::pinMode(26, OUTPUT);  //define red pin
  WiFiDrv::pinMode(27, OUTPUT);  //define blue pin
  myservo.attach(2);



  // Defined in thingProperties.h
  initProperties();

  // Connect to Arduino IoT Cloud
  ArduinoCloud.begin(ArduinoIoTPreferredConnection);
  //Serial1.begin(115200);
  //Serial1.begin(9600);
  u8g2.begin();

  u8g2.clearBuffer();
  u8g2.setFont(u8g2_font_helvB18_tf);
  u8g2.drawStr(0, 30, "Starting...");
  u8g2.sendBuffer();

  /*
     The following function allows you to obtain more information
     related to the state of network and IoT Cloud connection and errors
     the higher number the more granular information youâ€™ll get.
     The default is 0 (only errors).
     Maximum is 4
 */
  setDebugMessageLevel(2);
  ArduinoCloud.printDebugInfo();

  Wire.begin();  // Join I2C bus
  tube.setTubeType(TYPE_4, TYPE_4_DEFAULT_I2C_ADDR);
  tube.setBrightness(15);
  tube.setBlinkRate(/* BLINK_1HZ*/ BLINK_OFF);
  tube.displayString("STRT", 500);
  delay(2000);
  //tube.displayString("STRT",500);
  sensor_timer.every(500, get_button_pot_state);
  // sensor_timer.every(5000, get_sensor_readings);
  myservo.attach(2);
}

void loop() {
  ArduinoCloud.update();
  // Your code here
  DHT_SENSOR_READ();
  tube.displayString("BHEL", 500);
  delay(500);
  sensor_timer.tick();  // tick the timer
  delay(1000);
  tube.displayString("SRVO", 500);
  delay(500);
  tube.displayNum(servo_1);
 delay(500);
  tube.displayString("CHA", 500);
 delay(500);
  if (Drive_Run) {
  tube.displayString("RUN", 500);
  delay(500);
  tube.displayString("RPM", 500);
  delay(500);
  temp_rpm = (uint32_t)((float)led_pwd / 255.0f * 1500.0f);
  tube.displayNum(temp_rpm);
  delay(500);
} else {
  tube.displayString("IDLE", 500);
}
  delay(500);
  tube.displayString("CHB", 500);
  delay(500);
  CHB = digitalRead(CHB_STATUS_CHA);

  if (CHB) {
    tube.displayString("RUN", 500);
      delay(500);
     tube.displayString("RPM", 500);
     delay(500);
     temp_rpm = (uint32_t)((float)led_pwd / 255.0f * 1500.0f);
  tube.displayNum(temp_rpm);
  delay(500);
  } else {
    tube.displayString("IDLE", 500);
    //delay(500);
  }
  // Check if data is available on Serial1
  // Check if data is available on Serial1
  if (Serial1.available()) {
    uint8_t receivedByte = Serial1.read();
    // Print received data to Serial Monitor
    Serial.print("Received: ");
    Serial.print(receivedByte);
    Serial.print(" (0x");
    Serial.print(receivedByte, HEX);
    Serial.println(")");
    // Optional: Echo back to TMS320F28379D
    // Serial1.write(receivedByte);
  }


  if (timer.isActive()) {
    WiFiDrv::analogWrite(25, 255);  // turn on Green LED in RGB
    WiFiDrv::analogWrite(26, 0);    // turn off Red LED in RGB
    WiFiDrv::analogWrite(27, 0);    // turn off Blue LED in RGB
  } else {
    WiFiDrv::analogWrite(25, 0);    // turn off Green LED in RGB
    WiFiDrv::analogWrite(26, 0);    // turn off Red LED in RGB
    WiFiDrv::analogWrite(27, 255);  // turn on Blue LED in RGB
    delay(500);
    WiFiDrv::analogWrite(25, 0);    // turn off Green LED in RGB
    WiFiDrv::analogWrite(26, 255);  // turn off Red LED in RGB
    WiFiDrv::analogWrite(27, 0);    // turn on Blue LED in RGB
  }
 // delay(100);
  sendDataToF28379D_1();
  delay(10);
}


/*
  Since LedOnOff is READ_WRITE variable, onLedOnOffChange() is
  executed every time a new value is received from IoT Cloud.
*/
void onLedOnOffChange() {
  // Add your code here to act upon LedOnOff change
  if (led_on_off) {
    tube.displayString("CHB ON", 500);
  } else {
    tube.displayString("CHB OFF", 500);
  }
}




/*
  Since DriveRun is READ_WRITE variable, onDriveRunChange() is
  executed every time a new value is received from IoT Cloud.
*/
void onDriveRunChange() {
  // Add your code here to act upon DriveRun change
}

/*
  Since DriveStop is READ_WRITE variable, onDriveStopChange() is
  executed every time a new value is received from IoT Cloud.
*/
void onDriveStopChange() {
  // Add your code here to act upon DriveStop change
}


void printValues() {
  Serial.print("Button: ");
  Serial.println(button);
  Serial.print("pot: ");
  Serial.println(pot);
  Serial.print("led_pwd: ");
  Serial.println(led_pwd); //temp_rpm
  Serial.print("temp_rpm: ");
  Serial.println(temp_rpm); 
  Serial.print("Servo:");
  Serial.println(servo_1);
  Serial.print("CHB status:");
  Serial.println(CHB);


  Serial.println(temperature);
  Serial.println(humidity);
  Serial.println(Drive_Run);

  Serial.println();
  update_oled();
}

/*
  Since Button is READ_WRITE variable, onButtonChange() is
  executed every time a new value is received from IoT Cloud.
*/
void onButtonChange() {
  // Add your code here to act upon Button change
}

/*
  Since LedPwd is READ_WRITE variable, onLedPwdChange() is
  executed every time a new value is received from IoT Cloud.
*/
void onLedPwdChange() {
  // Add your code here to act upon LedPwd change

  // Add your code here to act upon LedPwd change
  analogWrite(5, led_pwd);
  Serial.println(led_pwd);
}

/*
  Since Pot is READ_WRITE variable, onPotChange() is
  executed every time a new value is received from IoT Cloud.
*/
void onPotChange() {
  // Add your code here to act upon Pot change
}

void update_oled() {
  u8g2.clearBuffer();
  u8g2.setFont(u8g2_font_luRS10_tf);
  u8g2.setFontPosTop();

  u8g2.setCursor(1, 5);
  u8g2.print(String(temperature) + (char)176 + "C");
  //u8g2.print("String(temperature)" + (char)176 + "C");
  //u8g2.print("24 C");
  u8g2.setCursor(85, 25);

  u8g2.print(String(humidity, 1) + "%");  // Round humidity float to 1 decimal so it fits.
  // u8g2.print(String(humidity,1) + "%");  // Round humidity float to 1 decimal so it fits.
  //u8g2.print("64.3%");  // Round humidity float to 1 decimal so it fits.
  u8g2.setCursor(1, 45);
  u8g2.print(pot);

  u8g2.setCursor(1, 25);
  //  u8g2.print(String(pressure) + "hPa");
  // u8g2.print("23 hPa");
  u8g2.print("Servo=" + String(servo_1));
  u8g2.setCursor(1, 65);
  u8g2.print("serial");
  //u8g2.print("serial"+ receivedByte);
  u8g2.setCursor(105, 5);
  if (button)
    u8g2.print("O");
  else
    u8g2.print("|");

  u8g2.setCursor(60, 5);
  if (Drive_Run)
    u8g2.print("D-ON");
  //   tube.displayString("D-ON",500);
  // delay(1000);
  else
    u8g2.print("D-OFF");
  //   tube.displayString("D-OFF",500);
  // delay(1000);


  u8g2.setCursor(40, 45);
  u8g2.print(message_one);

  u8g2.sendBuffer();
}

/*
  Since Timer is READ_WRITE variable, onTimerChange() is
  executed every time a new value is received from IoT Cloud.
*/
void onTimerChange() {
  // Add your code here to act upon Timer change
}

/*
  Since MessageOne is READ_WRITE variable, onMessageOneChange() is
  executed every time a new value is received from IoT Cloud.
*/
void onMessageOneChange() {
  // Add your code here to act upon MessageOne change
  update_oled();
}

void DHT_SENSOR_READ()


{
  float h = dht.readHumidity();
  float t = dht.readTemperature();
  temperature = t;
  humidity = h;
  Serial.print("Temperture - ");
  Serial.println(t);
  Serial.print("Humidity - ");
  Serial.println(h);
  printValues();
  delay(500);
}

/*
  Since Temperature is READ_WRITE variable, onTemperatureChange() is
  executed every time a new value is received from IoT Cloud.
*/
void onTemperatureChange() {
  // Add your code here to act upon Temperature change
}

/*
  Since Humidity is READ_WRITE variable, onHumidityChange() is
  executed every time a new value is received from IoT Cloud.
*/
void onHumidityChange() {
  // Add your code here to act upon Humidity change
}


/*
  Since Relay1 is READ_WRITE variable, onRelay1Change() is
  executed every time a new value is received from IoT Cloud.
*/
void onRelay1Change() {
  // Add your code here to act upon Relay1 change
  digitalWrite(relay_pin_1, relay_1);
  tube.displayString("R-ON", 500);
  delay(1000);
}

/*
  Since Servo1 is READ_WRITE variable, onServo1Change() is
  executed every time a new value is received from IoT Cloud.
*/
void onServo1Change() {
  // Add your code here to act upon Servo1 change
  myservo.write(servo_1);
  tube.displayString("SRVO", 500);
  tube.displayNum(servo_1);
  delay(1000);
  Serial.println(servo_1);
}

// shk
void sendDataToF28379D_1() {
  char str[34];        // enough space for your message
  char str_a[50];      // enough space for your message
  uint8_t packet[19];  // adjust size based on your data
  packet[0] = 'S';  // Start marker
                    // Add binary values (0 or 1) for boolean flags
  packet[1] = Drive_Run ? 1 : 0;
  packet[2] = button ? 1 : 0;
  packet[3] = drive_CHB_OFF ? 1 : 0;
  packet[4] = drive_CHB_ON ? 1 : 0;
  packet[5] = Drive_Run ? 1 : 0;
  packet[6] = Drive_Stop ? 1 : 0;
  packet[7] = led_on_off ? 1 : 0;
  int16_t temp = (int16_t)(temperature * 100);
  packet[8] = temp & 0xFF;
  packet[9] = (temp >> 8) & 0xFF;
  int16_t temp_Led_pwd = (int16_t)(led_pwd);
  packet[10] = temp_Led_pwd & 0xFF;
  packet[11] = (temp_Led_pwd >> 8) & 0xFF;
  int16_t temp_pot = pot;
    packet[12] = temp_pot & 0xFF;
  packet[13] = (temp_pot >> 8) & 0xFF;
  int16_t hum = (int16_t)(humidity * 100);
  packet[14] = hum & 0xFF;
  packet[15] = (hum >> 8) & 0xFF;
  int16_t temp_servo = servo_1;
  packet[16] = temp_servo  & 0xFF;
  packet[17] = (temp_servo  >> 8) & 0xFF;
  packet[18] = 'E';  // End marker
                                // sprintf(str, "%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d%d",
                                //         packet[0], packet[1], packet[2], packet[3], packet[4], packet[5], packet[6], packet[7], packet[8], packet[9], packet[10], packet[11], packet[12], packet[13], packet[14], packet[15], packet[16]);
  Serial1.write(packet, sizeof(packet));
 // Serial.println(str);
 Serial.write(packet, sizeof(packet));
 //char value=sizeof(packet);
 // Serial.print("Length including spaces: ");
 // sprintf(str, "%d",value);
  //Serial.println(str);
  //Serial1.write(str);

  
}



/*void receiveDataFromF28379D() {
  if (Serial1.available()) {
    String received_data = Serial1.readStringUntil('E');
    
    // Check if data starts with 'S'
    if (received_data.charAt(0) == 'S') {
      // Remove the start marker
      received_data = received_data.substring(1);
      
      // Parse the binary values
      int recv_button = received_data.charAt(0) - '0';
      int recv_drive_OFF = received_data.charAt(1) - '0';
      int recv_drive_ON = received_data.charAt(2) - '0';
      int recv_Drive_Run = received_data.charAt(3) - '0';
      int recv_Drive_Stop = received_data.charAt(4) - '0';
      int recv_led_on_off = received_data.charAt(5) - '0';
      
      // Find positions for numerical data
      int pos = 6;
      int endPos = received_data.indexOf('E', pos);
      if (endPos == -1) endPos = received_data.length();
      
      // Parse temperature, led_pwd, pot, humidity
      String temp_str = received_data.substring(pos, pos + 4);
      int recv_temp = temp_str.toInt();
      
      pos += temp_str.length();
      String led_pwd_str = received_data.substring(pos, pos + 3);
      int recv_led_pwd = led_pwd_str.toInt();
      
      pos += led_pwd_str.length();
      String pot_str = received_data.substring(pos, pos + 4);
      int recv_pot = pot_str.toInt();
      
      pos += pot_str.length();
      String humidity_str = received_data.substring(pos);
      int recv_humidity = humidity_str.toInt();
      
      // Process the received data as needed
      Serial.println("Received data from F28379D:");
      Serial.println("Button: " + String(recv_button));
      Serial.println("Temp: " + String(recv_temp/100.0));
      Serial.println("LED PWD: " + String(recv_led_pwd));
    }
  }
} */



/*void receiveDataFromF28379D() {
  if (Serial1.available() >= 14) {  // Check if complete packet available
    byte packet[20];
    int index = 0;
    
    // Look for start marker
    while (Serial1.available() && index == 0) {
      byte b = Serial1.peek();
      if (b == 'S') {
        break;  // Found the start marker
      } else {
        Serial1.read();  // Discard until start marker
      }
    }
    
    // Read the packet
    if (Serial1.available() >= 14 && Serial1.peek() == 'S') {
      Serial1.readBytes(packet, 14);
      
      // Verify start/end markers
      if (packet[0] == 'S' && packet[13] == 'E') {
        // Extract boolean values
        bool recv_button = packet[1];
        bool recv_drive_OFF = packet[2];
        bool recv_drive_ON = packet[3];
        bool recv_Drive_Run = packet[4];
        bool recv_Drive_Stop = packet[5];
        bool recv_led_on_off = packet[6];
        
        // Extract 16-bit values
        int16_t recv_temp = (packet[8] << 8) | packet[7];
        int recv_led_pwd = packet[9];
        int recv_pot = packet[10];
        int16_t recv_humidity = (packet[12] << 8) | packet[11];
        
        // Process received data
        Serial.println("***************************************");
        Serial.println("Received binary from TMS320F2839D packet:");
        Serial.println("Button: " + String(recv_button));
         Serial.println("drive_OFF: " + String(recv_drive_OFF));
         Serial.println("drive_ON: " + String(recv_drive_ON));
         Serial.println("Drive_Run: " + String(recv_Drive_Run));
         Serial.println("Drive_Stop: " + String(recv_Drive_Stop));
         Serial.println("led_on_off: " + String(recv_led_on_off));
        Serial.println("Temp: " + String(recv_temp/100.0));
        Serial.println("LED PWD: " + String(recv_led_pwd));
        Serial.println("POT: " + String(recv_pot));
        Serial.println("Humidity: " + String(recv_humidity/100.0));
        Serial.println("***************************************");
      }
    }
  }
}
*/






/*
  Since DriveCHBOFF is READ_WRITE variable, onDriveCHBOFFChange() is
  executed every time a new value is received from IoT Cloud.
*/
void onDriveCHBOFFChange() {
  // Add your code here to act upon DriveCHBOFF change

  if (drive_CHB_OFF) {


    digitalWrite(4, HIGH);
    delay(1000);
    digitalWrite(4, LOW);

    Serial.println("Drive OFF");
    tube.displayString("CHA OFF", 500);
    delay(1000);
    Drive_Stop = 1;
    Drive_Run = 0;
  }
}

/*
  Since DriveCHBOFF is READ_WRITE variable, onDriveCHBOFFChange() is
  executed every time a new value is received from IoT Cloud.
*/


/*
  Since DriveCHBON is READ_WRITE variable, onDriveCHBONChange() is
  executed every time a new value is received from IoT Cloud.
*/
void onDriveCHBONChange() {
  // Add your code here to act upon DriveCHBON change

  if (drive_CHB_ON) {
    digitalWrite(6, HIGH);
    delay(1000);
    digitalWrite(6, LOW);

    Serial.println("Drive ON");
    tube.displayString("CHA ON", 500);
    delay(500);
    Drive_Stop = 0;
    Drive_Run = 1;
  }
}
